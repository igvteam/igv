package org.broad.igv.ui.legend;

import com.intellij.uiDesigner.core.GridConstraints;
import com.intellij.uiDesigner.core.GridLayoutManager;
import com.intellij.uiDesigner.core.Spacer;
import org.broad.igv.ui.color.ColorPalette;
import org.broad.igv.ui.color.ColorUtilities;
import org.broad.igv.ui.color.PaletteColorTable;

import javax.swing.*;
import javax.swing.table.AbstractTableModel;
import javax.swing.table.TableCellEditor;
import javax.swing.table.TableCellRenderer;
import java.awt.*;
import java.awt.event.*;
import java.util.*;
import java.util.List;
import java.util.stream.Collectors;

public class DiscreteColorScaleEditor extends JDialog {
    private JPanel contentPane;
    private JButton buttonOK;
    private JButton buttonCancel;
    private JTable table;
    private ColorTableModel tableModel;
    private PaletteColorTable colorScale;
    private ColorPalette palette;
    private boolean isCancelled = false;

    public DiscreteColorScaleEditor(Frame parent, boolean modal, PaletteColorTable startingScale) {
        super(parent, modal);
        this.setLocationRelativeTo(parent);
        this.colorScale = startingScale;
        this.palette = startingScale.getPalette();

        $$$setupUI$$$();
        setContentPane(contentPane);
        setModal(true);
        getRootPane().setDefaultButton(buttonOK);

        buttonOK.addActionListener(e -> onOK());
        buttonCancel.addActionListener(e -> onCancel());

        // call onCancel() when cross is clicked
        setDefaultCloseOperation(DO_NOTHING_ON_CLOSE);
        addWindowListener(new WindowAdapter() {
            public void windowClosing(WindowEvent e) {
                onCancel();
            }
        });

        // call onCancel() on ESCAPE
        contentPane.registerKeyboardAction(e -> onCancel(), KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0), JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);


    }

    private void onOK() {
        colorScale = tableModel.getColorTable();
        dispose();
    }

    private void onCancel() {
        isCancelled = true;
        dispose();
    }

    public boolean isCancelled() {
        return isCancelled;
    }

    public PaletteColorTable getColorScale() {
        return colorScale;
    }

    public static void main(String[] args) {
        Map<String, Color> defaultColors = Map.of("indel", new Color(0, 100, 100), "snp", new Color(50, 50, 200));
        PaletteColorTable colorTable = new PaletteColorTable(ColorUtilities.getPalette("Pastels 1"));
        defaultColors.forEach(colorTable::put);
        DiscreteColorScaleEditor dialog = new DiscreteColorScaleEditor(new Frame(), true, colorTable);
        dialog.pack();
        dialog.setVisible(true);
        System.exit(0);
    }

    /**
     * Method generated by IntelliJ IDEA GUI Designer
     * >>> IMPORTANT!! <<<
     * DO NOT edit this method OR call it in your code!
     *
     * @noinspection ALL
     */
    private void $$$setupUI$$$() {
        createUIComponents();
        contentPane = new JPanel();
        contentPane.setLayout(new GridLayoutManager(2, 1, new Insets(10, 10, 10, 10), -1, -1));
        final JPanel panel1 = new JPanel();
        panel1.setLayout(new GridLayoutManager(1, 2, new Insets(0, 0, 0, 0), -1, -1));
        contentPane.add(panel1, new GridConstraints(1, 0, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, 1, null, null, null, 0, false));
        final Spacer spacer1 = new Spacer();
        panel1.add(spacer1, new GridConstraints(0, 0, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_WANT_GROW, 1, null, null, null, 0, false));
        final JPanel panel2 = new JPanel();
        panel2.setLayout(new GridLayoutManager(1, 2, new Insets(0, 0, 0, 0), -1, -1, true, false));
        panel1.add(panel2, new GridConstraints(0, 1, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, null, null, null, 0, false));
        buttonOK = new JButton();
        buttonOK.setText("OK");
        panel2.add(buttonOK, new GridConstraints(0, 0, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));
        buttonCancel = new JButton();
        buttonCancel.setText("Cancel");
        panel2.add(buttonCancel, new GridConstraints(0, 1, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));
        final JPanel panel3 = new JPanel();
        panel3.setLayout(new GridLayoutManager(1, 1, new Insets(0, 0, 0, 0), -1, -1));
        contentPane.add(panel3, new GridConstraints(0, 0, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, null, null, null, 0, false));
        final JScrollPane scrollPane1 = new JScrollPane();
        panel3.add(scrollPane1, new GridConstraints(0, 0, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_WANT_GROW, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_WANT_GROW, null, null, null, 0, false));
        table.setAutoCreateRowSorter(false);
        table.setFillsViewportHeight(true);
        scrollPane1.setViewportView(table);
    }

    /**
     * @noinspection ALL
     */
    public JComponent $$$getRootComponent$$$() {
        return contentPane;
    }

    private void createUIComponents() {
        tableModel = new ColorTableModel(colorScale.getColorMap());

        tableModel.addDefaultRow(); // always add a bonus one for editing
        tableModel.addTableModelListener(e -> {
            if ((e.getLastRow() + 1) == tableModel.getRowCount()) {
                tableModel.addDefaultRow();
            }
        });

        table = new JTable(tableModel);
        table.getColumnModel().getColumn(1).setPreferredWidth(50);
        table.getColumnModel().getColumn(0).setPreferredWidth(100);
        table.setDefaultRenderer(Color.class, new ColorRenderer(false));
        table.setDefaultEditor(Color.class, new ColorEditor());

    }

    private class ColorTableModel extends AbstractTableModel {

        public static final int VALUE_COL = 0;
        private final Color defaultColor = Color.lightGray;

        private record ColorEntry(String name, Color color) {
        }

        private final List<ColorEntry> data = new ArrayList<>();

        ColorTableModel(Map<String, Color> inputData) {
            inputData.forEach((k, v) -> data.add(new ColorEntry(k, v)));
            fireTableDataChanged();
        }

        public void addDefaultRow() {
            addRow(null, defaultColor);
        }

        public void addRow(String value, Color color) {
            data.add(new ColorEntry(value, color));
            int row = getRowCount();
            fireTableRowsInserted(row, row);
        }


        @Override
        public String getColumnName(int column) {
            return List.of("Value", "Color").get(column);
        }

        @Override
        public Class<?> getColumnClass(int columnIndex) {
            return List.of(String.class, Color.class).get(columnIndex);
        }

        @Override
        public boolean isCellEditable(int rowIndex, int columnIndex) {
            return columnIndex < 2 && rowIndex <= data.size();
        }

        @Override
        public void setValueAt(Object aValue, int rowIndex, int columnIndex) {
            if (rowIndex < data.size()) {
                ColorEntry previousEntry = data.get(rowIndex);
                data.set(rowIndex, columnIndex == VALUE_COL
                        ? new ColorEntry((String) aValue, previousEntry.color())
                        : new ColorEntry(previousEntry.name(), (Color) aValue));
            } else if (rowIndex == data.size()) {
                data.add(columnIndex == VALUE_COL ? new ColorEntry((String) aValue, defaultColor)
                        : new ColorEntry(null, (Color) aValue));
            }
            fireTableCellUpdated(rowIndex, columnIndex);
        }

        @Override
        public int getRowCount() {
            return data.size();
        }

        @Override
        public int getColumnCount() {
            return 2;
        }

        @Override
        public Object getValueAt(int rowIndex, int columnIndex) {
            ColorEntry row = data.get(rowIndex);
            return columnIndex == VALUE_COL ? row.name() : row.color();
        }

        public PaletteColorTable getColorTable() {
            LinkedHashMap<String, Color> map = data.stream()
                    .filter(r -> r.name != null && !r.name.isBlank())
                    .collect(
                            Collectors.toMap(
                                    ColorEntry::name,
                                    ColorEntry::color,
                                    (r1, r2) -> r1,
                                    LinkedHashMap::new));
            PaletteColorTable colorTable = new PaletteColorTable(palette);
            map.forEach(colorTable::put);
            return colorTable;
        }
    }


    private static class ColorRenderer extends JLabel
            implements TableCellRenderer {

        private final boolean isBordered;

        public ColorRenderer(boolean isBordered) {
            this.isBordered = isBordered;
            setOpaque(true); //MUST do this for background to show up.
        }

        public Component getTableCellRendererComponent(
                JTable table, Object color,
                boolean isSelected, boolean hasFocus,
                int row, int column) {
            Color newColor = (Color) color;
            setBackground(newColor);
//            if (isBordered) {
//                if (isSelected) {
//                    //selectedBorder is a solid border in the color
//                    //table.getSelectionBackground().
//                    setBorder(selectedBorder);
//                } else {
//                ...
//                    //unselectedBorder is a solid border in the color
//                    //table.getBackground().
//                    setBorder(unselectedBorder);
//                }
//            }

            //setToolTipText(...); //Discussed in the following section
            return this;
        }
    }


    public static class ColorEditor extends AbstractCellEditor
            implements TableCellEditor,
            ActionListener {
        Color currentColor;
        JButton button;
        JColorChooser colorChooser;
        JDialog dialog;
        protected static final String EDIT = "edit";

        public ColorEditor() {
            button = new JButton();
            button.setActionCommand(EDIT);
            button.addActionListener(this);
            button.setBorderPainted(false);

            //Set up the dialog that the button brings up.
            colorChooser = new JColorChooser();
            dialog = JColorChooser.createDialog(button,
                    "Pick a Color",
                    true,  //modal
                    colorChooser,
                    this,  //OK button handler
                    null); // no CANCEL button handler
        }

        public void actionPerformed(ActionEvent e) {
            if (EDIT.equals(e.getActionCommand())) {
                //The user has clicked the cell, so
                //bring up the dialog.
                button.setBackground(currentColor);
                colorChooser.setColor(currentColor);
                dialog.setVisible(true);
                dialog.toFront();

                fireEditingStopped(); //Make the renderer reappear.

            } else { //User pressed dialog's "OK" button.
                currentColor = colorChooser.getColor();
            }
        }

        //Implement the one CellEditor method that AbstractCellEditor doesn't.
        public Object getCellEditorValue() {
            return currentColor;
        }

        //Implement the one method defined by TableCellEditor.
        public Component getTableCellEditorComponent(JTable table,
                                                     Object value,
                                                     boolean isSelected,
                                                     int row,
                                                     int column) {
            currentColor = (Color) value;
            return button;
        }
    }


}
